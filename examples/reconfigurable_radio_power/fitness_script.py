import math
import operator
import csv

from deap import base
from deap import creator
from deap import tools

from numpy import *
from copy import deepcopy 
from numpy.random import uniform, seed,rand

cost_maxVal = 1.0
cost_minVal = 0.0

initMin = -1
initMax = 1

global reconfiguration_time_set
rotate = False

#aecc or execution time
functionType = "execution_time"

reconfiguration_time_set = 0

designSpace = [ #[min,max,stepSize]#
                    {"min":1.0,"max":80.0,"step":1.0,"type":"discrete","smin":-35.0,"smax":35.0},
                    {"min":100.0,"max":300.0,"step":1.0,"type":"discrete","smin":-45.0,"smax":45.0},
                    #{"min":0.0,"max":1.0,"step":1.0,"type":"discrete","smin":-1.0,"smax":1.0}
                    #[0,1,1]
              ]
             # 1, 2, 4, 7, 8, 14, 16, 28, 56, 112
              
minVal = 0.0
if reconfiguration_time_set == 0:
    maxvalue = 10.0
    
else:
    maxvalue = 100.0
maxVal = maxvalue
worst_value = maxVal
def name():
    return "radio" + str(designSpace[1]["min"]) + "_" + str(reconfiguration_time_set)
        
error_labels = {0:'Valid',1:'Timing',2:'Overmap'}

def get_z_axis_name():
    return "$t_{total}$ (ms)"
    
def get_x_axis_name():
    return "p"
     
def get_y_axis_name():
    return "freq. (MHz)"

def termCond(best):
    global reconfiguration_time_set
    if reconfiguration_time_set == 0:   
        return best < 0.526             
    else:
        return best < 8.38

def interpolate(fx, x, fy, y, z):
    return (fx-fy)/(x-y) * z + fy
        
def fitnessFunc(particle):
    global reconfiguration_time_set,maxvalue
    # Dimensions dynamically rescalled
    # All 
    ############Dimensions
    p = int(particle[0])
    frequency = int(particle[1])
    #particle[1]#int((particle[2]+1)/1.5) ## 0 or 1 value
    #######################
    # optimial setting for level of parallelism for fast reconfiguration is 18 cores. 
    ####
    steps = 80.0
    n = 10000.0 
        
    ## all the data is extracted from page 100 of Tobias Becker Thesis
    vhdl =  False
    if vhdl: ## 
        try:
            maxfreq = {5:110.0,10:120.0,20:120.0,40:145.0,80:182.0}[p]
            Luts = {5:1774,10:3129,20:5058,40:6278,80:9452}[p]
            tp_e = {5:9.09,10:8.33,20:8.33,40:6.89,80:5.49}[p]
            tr_e = {5:43.6,10:38.4,20:31.1,40:19.3,80:14.5}[p]
            Epn = {5:57.9,10:42.0,20:25.9,40:12.5,80:6.8}[p]
            Ern = {5:3.9,10:7.0,20:11.3,40:14.0,80:21.1}[p]
        except:
            if p < 5:
                maxfreq = interpolate(120.0, 10.0, 110.0, 5.0, p-5)
                Luts = interpolate(3129.0, 5, 1774.0, 10, p) ## we interpolate using our last curve
                tp_e = interpolate(8.33, 5, 9.09, 10, p)
                tr_e = interpolate(38.4, 5, 43.6, 10, p)
                Epn = interpolate(42.0, 5, 57.9, 10, p)
                Ern = interpolate(7.0, 5, 3.9, 10, p)
            elif p == 16:
                maxfreq = 120.0
                Luts = interpolate(5058.0, 20, 3129.0, 10,  6) ## we interpolate using our last curve
                tp_e = 8.33
                tr_e = interpolate( 31.1, 20, 38.4, 10, 6)
                Epn = interpolate(25.9, 20, 42.0, 10, 6)
                Ern = interpolate(11.3, 20, 7.0, 10,  6)
            else:
                raise Exception("maxfrequency not speciifed for the supplied parameter")    
    else: ## vhdl design
        if p == 80:
            tr_e = 18.5
        else:
            tr_e = 20.5
        tp_e = 3.3
        try: ## for collected designs
            maxfreq = {5:110.0,10:120.0,20:120.0,40:145.0,80:182.0}[p]
            Luts = {5:841.0,10:1674.0,20:3321.0,40:6652.0,80:12039.0}[p]
            Epn = {5:23.6,10:14.4,20:10.2,40:8.5,80:6.4}[p]
            Ern = {5:1.9,10:3.7,20:7.4,40:14.8,80:27.0}[p]
        except: ## for designs that got to be interpollated... cant be generated by coregens
            maxfreq = interpolate(307.0, 5, 303.0, 80, p)
            if p < 5:
                Luts = interpolate(1674.0.0, 5, 841.0, 10, p) ## we interpolate using our last curve
                Epn = interpolate(14.4, 5, 23.6, 10, p)
                Ern = interpolate(1.9, 5, 3.7, 10, p)
            elif p == 16:
                Luts = interpolate(3321.0, 20, 1674.0, 10, p) ## we interpolate using our last curve
                Epn = interpolate(10.2, 20, 14.4, 10, p)
                Ern = interpolate(7.4, 20, 3.7, 10, p)
            else:
                raise Exception("maxfrequency not speciifed for the supplied parameter")    

    t_pe = 1000.0/frequency ### ns
    t_pe = t_pe * 1e-6 ### ms

    t_total = (steps*n/p+p-1)*t_pe + t_r*p
    ## check application throughput
    
    #print "p ",p," frequency ",frequency," reconfiguration_time ",reconfiguration_time," t_total ",t_total," proccesing_time ",( n * (steps * proccesing_time) / p)
    cost = 0.5
    if frequency > maxfreq:
        return (array([maxvalue]),array([1]),array([1]),array([cost]))
        
    #if Luts > max_Luts:
    if False : ##we currently disable overmap
        return (array([maxvalue]),array([2]),array([1]),array([cost]))

    if functionType == "execution_time":
        return (array([t_total]),array([0]),array([0]),array([cost]))

    elif functionType == "aecc":
    
        apcc = p / steps * frequency
        aecc = ( n * (steps * proccesing_time) / p) * apcc
        return (array([aecc]),array([0]),array([0]),array([cost]))
        
def changeParams(params):
    global designSpace,reconfiguration_time_set,maxvalue,maxVal,minVal
    try:
        reconfiguration_time_set = params["reconfiguration_time_set"]
    except Exception,e:
        print "[changeParams] ",e
        pass
    try:
        designSpace = [ #[min,max,stepSize]#
                        {"min":1.0,"max":112.0,"step":1.0,"type":"discrete","smin":-35.0,"smax":35.0},
                        {"min":params["min"],"max":300.0,"step":1.0,"type":"discrete","smin":-45.0,"smax":45.0},
                        #{"min":0.0,"max":1.0,"step":1.0,"type":"discrete","smin":-1.0,"smax":1.0}
                        #[0,1,1]
                  ]
        minVal = 0.0          
        if reconfiguration_time_set == 0:
            maxvalue = 10.0    
        else:
            maxvalue = 100.0
            
        maxVal = maxvalue
        worst_value = maxVal
    except Exception,e:
        print "[changeParams] ",e
        pass
        
def trialgen():
    params = {}
    global reconfiguration_time_set
    for reconfiguration_time_set in [0,1]:
        for min in [200.0]:
            params["min"] = min
            params["reconfiguration_time_set"] = reconfiguration_time_set
            changeParams(params)
            yield params
            
def calcMax():    
    if len(designSpace)==2:
        # make up data.
        x,y = mgrid[designSpace[0]["min"]:designSpace[0]["max"]:(int(designSpace[0]["max"]-designSpace[0]["min"])+1)*1.0j,designSpace[1]["min"]:designSpace[1]["max"]:(int(designSpace[1]["max"]-designSpace[1]["min"])+1)*1.0j]
        x=reshape(x,-1)
        y=reshape(y,-1)       
        z = array([[a,b] for (a,b) in zip(x,y)])
    else:
        x,y,v = mgrid[designSpace[0]["min"]:designSpace[0]["max"]:(int(designSpace[0]["max"]-designSpace[0]["min"])+1)*1.0j,designSpace[1]["min"]:designSpace[1]["max"]:(int(designSpace[1]["max"]-designSpace[1]["min"])+1)*1.0j , designSpace[2]["min"]:designSpace[2]["max"]:(int(designSpace[2]["max"]-designSpace[2]["min"])+1)*1.0j]
        x=reshape(x,-1)
        y=reshape(y,-1)
        v=reshape(v,-1)
        z = array([[a,b,c] for (a,b,c) in zip(x,y,v)])
        
    zReal = array([fitnessFunc(a)[0][0] for a in z])
    zRealClass = array([fitnessFunc(a)[1][0] for a in z])
    minn = argmin(zReal)
    filteredminn = []
    filteredZ=[]
    for i,zreal in enumerate(zReal):
        if zRealClass[i]==0.0:
            filteredminn.append(zreal)
            filteredZ.append(z[i])
            
    if filteredminn:
        doFor=5
        argsortedFiltered = argsort(filteredminn,axis=0)
        print "[returnMaxS2] ====================================="
        for kk in range(0,doFor):
            minn = argsortedFiltered[kk]
            maxx = argsortedFiltered[-(kk+1)]
            print "[returnMaxS2] Real min :",minn," ",filteredZ[minn]," ",filteredminn[minn]
            print "[returnMaxS2] Real max :",maxx," ",filteredZ[maxx]," ",filteredminn[maxx]

        print "[returnMaxS2] ====================================="
